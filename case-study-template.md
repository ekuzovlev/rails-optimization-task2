[x] Построить и проанализировать отчёт гемом memory_profiler
[x] Построить и проанализировать отчёт ruby-prof в режиме Flat;
[x] Построить и проанализировать отчёт ruby-prof в режиме Graph;
[x] Построить и проанализировать отчёт ruby-prof в режиме CallStack;
[x] Построить и проанализировать отчёт ruby-prof в режиме CallTree c визуализацией в QCachegrind;
[x] Построить и проанализировать текстовый отчёт stackprof;
[x] Построить и проанализировать отчёт flamegraph с помощью stackprof и визуализировать его в speedscope.app;
[ ] Построить график потребления памяти в valgrind massif visualier и включить скриншот в описание вашего PR;
[ ] Написать тест, на то что программа укладывается в бюджет по памяти


# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: я решил измерять максимальный объем оперативной памяти, которую использует программа.
Бюджет, в который мы должны уложиться 70 мб на полном объеме данных.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: *как вы построили feedback_loop*

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- Файл 20_000 строк. 206 MB.
- В качестве эксперимента я прогнал программу через отчеты Stackprof, Rubyprof и MemoryProfiler. Решил остановиться на последнем, так как он показал внушительное потребление памяти на 57 строке и 1.15 GB.
- 57 строчка `sessions = sessions + [parse_session(line)] if cols[0] == 'session'`, думаю здесь надо использовать метод << вместо сложения массивов. Заодно подправил 56 строку, с аналогичной ситуацией для user.
- Отчет стал показывать 413.26 MB, а Memory Usage для программы - 110 MB

### Ваша находка №2
- Файл 20_000 строк. 110 MB.
- Решил использовать отчет callstack из гема RubyProf. Он показывает точку роста в методе парсинга даты. 20 % - на данный момент самый жирный кусок.
- Учитывая, что в этом методе много лишних действий, уберу ненужное.
- Метрика почти не изменилась. Хотя из отчета эта проблема ушла. Возможно пора увеличивать входной объем данных. Хотя MemoryProfiler, соглашаля что парсинг даты, в данный момент, не основная проблемя для памяти.
- как изменился отчёт профилировщика? Из callstack-отчета гема RubyProf проблема ушла. Из Memory Profiler нет.

### Ваша находка №3
- Файл 20_000 строк. 110 MB.
- Для отправной точки взял отчет Из Memory Profiler 413.26 MB на 103 строчку кода это наш старый знакомый `user_sessions = sessions.select { |session| session['user_id'] == user['id'] }`
- Переделываем на хэш
- 53 MB
- Из отчёта профилировщика проблема исчезла

### Ваша находка №4
- Файл 100_000 строк. 140 MB.
- из Memory Profiler можно отметить, большое потребление методом split и обильное использование строк. Но я бы охарактеризовал как, много всего по мелочи. Отчет callstack из RubyProf, больше выделяет метод split 17% в парсинге сессий и 20% в методе each. Причем показывает 200_000 вызовов на 100_000 строк, явно что-то лишнее.
- Удалил лишние вызовы метода split из парсеров 108 MB на выполнение программы. 
- Из callstack проблема сильно уменьшилась в объеме. Осталась только в методе Each.

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*
